/*
 * Copyright 2018 Valiantsin Kavalenka
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Contains tools for generating identifiers.
 * <p>
 * <b>Glossary</b><br>
 * <i>Identifier (ID)</i><br>
 * A piece of data which is unique within a defined scope. Such a piece of data can be used to identify something within the scope.
 * <p>
 * <i>ID generator</i><br>
 * A tool which generates identifiers. All ID generators manifest the following flavours:
 * ephemeral or persistent, monotonic (strictly increasing, strictly decreasing) or nonmonotonic, sparse or condensed (see below).
 * <p>
 * <i>ID generator range</i><br>
 * Range of an ID generator is a complete set of all identifiers which can be generated by the ID generator,
 * we will denote it by {@code G}. {@code G} is totally ordered if and only if all its elements are comparable
 * (e.i. all elements are ordered by the same lower than or equal/greater than or equal binary relation).
 * <p>
 * <i>Ephemeral/persistent flavour</i><br>
 * Any identifier generated by the same instance of an ID generator is always unique among all identifiers generated by this instance.
 * If this uniqueness guarantee holds among all identifiers generated by different instances of the ID generator,
 * even those created at different executions of the program, then the ID generator is persistent, otherwise it is ephemeral.
 * <p>
 * <i>Monotonic/nonmonotonic flavour</i><br>
 * If the range {@code G} of an ID generator is totally ordered,
 * and the ID generator produces identifiers in the order corresponding with such a total order,
 * then the ID generator is monotonic, otherwise it is nonmonotonic.
 * A monotonic ID generator can be either strictly increasing or strictly decreasing
 * depending on the definition of lower than or equal/greater than or equal binary relation.
 * <p>
 * Note that monotonicity does not guarantee that the generated identifiers are consecutive.
 * Furthermore, there is little to no sense in talking about consecutiveness for persistent monotonic generators
 * because an implementation of such a generator requires for a persistent storage to wait for a confirmation
 * that the generated ID was delivered to a requester before the next ID can be generated.
 * If the confirmation were not received, for example, because the requester crashed,
 * then the situation would require some sort of an investigation either automatic (after the requester comes back online), or manual.
 * If this sounds similar to the reason there are heuristic outcomes of a 2-phase commit (2PC),
 * (see for example
 * <a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.1/html/development_guide/java_transaction_api_jta#about_heuristic_outcomes">
 * RedHat About Heuristic Outcomes</a>
 * or <a href="https://www.atomikos.com/Documentation/HeuristicExceptions">Atomikos Heuristic Exceptions</a>), you are correct.
 * However, we can reason about sparseness.
 * <p>
 * <i>Sparse/condensed flavour</i><br>
 * For an ID generator which range {@code G} is a set of integral numbers there exist an integral number {@code sparseness >= 0}
 * such that for any identifier {@code id ∈ G} the following holds:
 * <ul>
 * <li>
 * {@code ((id - (sparseness + 1); id) ∪ (id; id + (sparseness + 1))) ∩ G = ∅}
 * </li>
 * <li>
 * there exist at least one {@code id' ∈ G} such that {@code ((id' - (sparseness + 2); id') ∪ (id'; id' + (sparseness + 2))) ∩ G ≠ ∅}.
 * </li>
 * </ul>
 * In other words {@code (sparseness + 1)} is the minimal value of {@code |id1 - id2|} among all {@code id1, id2 ∈ G} such that {@code id1 ≠ id2}.
 * <p>
 * An ID generator with {@code sparseness > 0} is called sparse,
 * and a generator for the degenerate case with {@code sparseness = 0} is called condensed.
 * <p>
 * <i>Compatible identifiers</i><br>
 * Multiple ID generators are compatible with each other
 * if and only if for each pair of generators {@code x} and {@code y} from our set
 * {@code G}<sub>{@code x }</sub>{@code ∩ G}<sub>{@code y}</sub>{@code ≠ ∅}.
 * Compatible ID generators can be combined into a new ID generator by simply joining their ranges.
 * E.g. if one of two ID generators produce only even integral numbers
 * and the other one produce only odd integral numbers, then these ID generators are compatible.
 */
package stincmale.idenator;
